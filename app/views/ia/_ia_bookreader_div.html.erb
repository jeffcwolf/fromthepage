<div class="inside-column" id="zoom_div">
	<div id="containerdiv">
		<div id="BookReader" style="left:10px; right:10px; top:10px; bottom:2em;">x</div>

    <link rel="stylesheet" type="text/css" href="../BookReader/BookReader.css?v=3.1.4" id="BRCSS">


    <!-- script src="/includes/jquery-1.4.2.min.js" type="text/javascript"></script -->
 <script type="text/javascript" src="http://www.archive.org/bookreader/jquery-ui-1.8.5.custom.min.js"></script>
    <script type="text/javascript" src="../BookReader/jquery-ui-1.8.5.custom.min.js?v=3.1.4"></script>
    <script type="text/javascript" src="../BookReader/dragscrollable.js?v=3.1.4"></script>
    <script type="text/javascript" src="../BookReader/jquery.colorbox-min.js"></script>
    <script type="text/javascript" src="../BookReader/jquery.ui.ipad.js"></script>

    <script type="text/javascript" src="../BookReader/jquery.bt.min.js"></script>
    <script type="text/javascript" src="../BookReader/BookReader.js?v=3.1.4"></script>
    
    <%= stylesheet_link_tag 'iaoverride' %>

	<script type="text/javascript" language="javascript">
		     // jQuery.noConflict();
// 
// //
// // This file is a copy of the dynamically-generated Internet Archive stuff
// //
// br = new BookReader();
// 
// br.titleLeaf = 3;
// 
// br.getPageWidth = function(index) {
    // return this.pageW[index];
// }
// 
// br.getPageHeight = function(index) {
    // return this.pageH[index];
// }
// 
// // Returns true if page image is available rotated
// br.canRotatePage = function(index) {
    // return 'jp2' == this.imageFormat; // Assume single format for now
// }
// 
// // reduce defaults to 1 (no reduction)
// // rotate defaults to 0 (no rotation)
// br.getPageURI = function(index, reduce, rotate) {
    // var _reduce;
    // var _rotate;
// 
    // if ('undefined' == typeof(reduce)) {
        // _reduce = 1;
    // } else {
        // _reduce = reduce;
    // }
    // if ('undefined' == typeof(rotate)) {
        // _rotate = 0;
    // } else {
        // _rotate = rotate;
    // }
// 
    // var file = this._getPageFile(index);
// 
    // // $$$ add more image stack formats here
// //    return 'http://'+this.server+'/BookReader/BookReaderImages.php?zip='+this.zip+'&file='+file+'&scale='+_reduce+'&rotate='+_rotate;
// //	return 'http://archive.org/download/ThorntonByLolaCarrBates/page/n4'
    // return 'https://ia802608.us.archive.org/BookReader/BookReaderImages.php?zip=/2/items/ThorntonByLolaCarrBates/Thornton_by_Lola_Carr_Bates_jp2.zip&file=Thornton_by_Lola_Carr_Bates_jp2/Thornton_by_Lola_Carr_Bates_0000.jp2&scale=14.678407350689127&rotate=0'
// }
// 
// br._getPageFile = function(index) {
    // var leafStr = '0000';
    // var imgStr = this.leafMap[index].toString();
    // var re = new RegExp("0{"+imgStr.length+"}$");
// 
    // var insideZipPrefix = this.subPrefix.match('[^/]+$');
    // var file = insideZipPrefix + '_' + this.imageFormat + '/' + insideZipPrefix + '_' + leafStr.replace(re, imgStr) + '.' + this.imageFormat;
// 
    // return file;
// }
// 
// br.getPageSide = function(index) {
    // //assume the book starts with a cover (right-hand leaf)
    // //we should really get handside from scandata.xml
// 
// 
    // // $$$ we should get this from scandata instead of assuming the accessible
    // //     leafs are contiguous
    // if ('rl' != this.pageProgression) {
        // // If pageProgression is not set RTL we assume it is LTR
        // if (0 == (index & 0x1)) {
            // // Even-numbered page
            // return 'R';
        // } else {
            // // Odd-numbered page
            // return 'L';
        // }
    // } else {
        // // RTL
        // if (0 == (index & 0x1)) {
            // return 'L';
        // } else {
            // return 'R';
        // }
    // }
// }
// 
// br.getPageNum = function(index) {
    // var pageNum = this.pageNums[index];
    // if (pageNum) {
        // return pageNum;
    // } else {
        // return 'n' + index;
    // }
// }
// 
// // Single images in the Internet Archive scandata.xml metadata are (somewhat incorrectly)
// // given a "leaf" number.  Some of these images from the scanning process should not
// // be displayed in the BookReader (for example colour calibration cards).  Since some
// // of the scanned images will not be displayed in the BookReader (those marked with
// // addToAccessFormats false in the scandata.xml) leaf numbers and BookReader page
// // indexes are generally not the same.  This function returns the BookReader page
// // index given a scanned leaf number.
// //
// // This function is used, for example, to map between search results (that use the
// // leaf numbers) and the displayed pages in the BookReader.
// br.leafNumToIndex = function(leafNum) {
    // for (var index = 0; index < this.leafMap.length; index++) {
        // if (this.leafMap[index] == leafNum) {
            // return index;
        // }
    // }
// 
    // return null;
// }
// 
// // This function returns the left and right indices for the user-visible
// // spread that contains the given index.  The return values may be
// // null if there is no facing page or the index is invalid.
// br.getSpreadIndices = function(pindex) {
    // // $$$ we could make a separate function for the RTL case and
    // //      only bind it if necessary instead of always checking
    // // $$$ we currently assume there are no gaps
// 
    // var spreadIndices = [null, null];
    // if ('rl' == this.pageProgression) {
        // // Right to Left
        // if (this.getPageSide(pindex) == 'R') {
            // spreadIndices[1] = pindex;
            // spreadIndices[0] = pindex + 1;
        // } else {
            // // Given index was LHS
            // spreadIndices[0] = pindex;
            // spreadIndices[1] = pindex - 1;
        // }
    // } else {
        // // Left to right
        // if (this.getPageSide(pindex) == 'L') {
            // spreadIndices[0] = pindex;
            // spreadIndices[1] = pindex + 1;
        // } else {
            // // Given index was RHS
            // spreadIndices[1] = pindex;
            // spreadIndices[0] = pindex - 1;
        // }
    // }
// 
    // //console.log("   index %d mapped to spread %d,%d", pindex, spreadIndices[0], spreadIndices[1]);
// 
    // return spreadIndices;
// }
// 
// // Remove the page number assertions for all but the highest index page with
// // a given assertion.  Ensures there is only a single page "{pagenum}"
// // e.g. the last page asserted as page 5 retains that assertion.
// br.uniquifyPageNums = function() {
    // var seen = {};
// 
    // for (var i = br.pageNums.length - 1; i--; i >= 0) {
        // var pageNum = br.pageNums[i];
        // if ( !seen[pageNum] ) {
            // seen[pageNum] = true;
        // } else {
            // br.pageNums[i] = null;
        // }
    // }
// 
// }
// 
// br.cleanupMetadata = function() {
    // br.uniquifyPageNums();
// }
// 
// // getEmbedURL
// //________
// // Returns a URL for an embedded version of the current book
// br.getEmbedURL = function() {
    // // We could generate a URL hash fragment here but for now we just leave at defaults
    // var url = 'http://' + window.location.host + '/stream/'+this.bookId;
    // if (this.subPrefix != this.bookId) { // Only include if needed
        // url += '/' + this.subPrefix;
    // }
    // url += '?ui=embed';
    // return url;
// }
// 
// // getEmbedCode
// //________
// // Returns the embed code HTML fragment suitable for copy and paste
// br.getEmbedCode = function() {
    // return "<iframe src='" + this.getEmbedURL() + "' width='480px' height='430px'></iframe>";
// }
// 
// 
// // these can be extrapolated from the file ID_scandata.xml
// // book->pageData->page->cropbox->w
// // question: why is this populated from leaf 3 on, rather than leaf 0?
// // answer: see comments above
// //
// // these can also be extrapolated from the file ID_djvu.xml
// // DjVuXML->BODY->OBJECT attr:width
// br.pageW = [ <%= @page.ia_leaf.page_w %>];
// 
// // these can be extrapolated from the file ID_scandata.xml
// // book->pageData->page->cropbox->h
// //
// // these can also be extrapolated from the file ID_djvu.xml
// // DjVuXML->BODY->OBJECT attr:height , whence also page titles can be received
// br.pageH = [ <%= @page.ia_leaf.page_h %>];
// 
// br.leafMap = [<%= @page.ia_leaf.leaf_number %>];
// 
// br.pageNums = [ '<%=@page.ia_leaf.page_number%>'];
// 
// 
// br.numLeafs = br.pageW.length;
// 
// 
// // bookPath and server may be derived from hitting the stream url -- see
// //  lynx -source "http://www.archive.org/stream/1941fieldnosla00klau"
// // output js include file
// 
// 
// /*
 // *
 // * br.bookId   = 'Jeremiah_White_Graves_Diary_Volume_2_Book_01';
 // * br.zip      = '/33/items/Jeremiah_White_Graves_Diary_Volume_2_Book_01/JWGravesVol2Book01_jp2.zip';
 // * br.subPrefix = 'JWGravesVol2Book01';
 // * br.server   = 'ia600607.us.archive.org';
 // * br.bookTitle= 'Diary of Jeremiah White Graves, Volume 2, Book 1';
 // * br.bookPath = '/33/items/Jeremiah_White_Graves_Diary_Volume_2_Book_01/JWGravesVol2Book01';
 // * br.bookUrl  = 'http://www.archive.org/details/Jeremiah_White_Graves_Diary_Volume_2_Book_01';
 // * br.imageFormat = 'jp2';
 // * br.archiveFormat = 'zip';
// 
 // *
 // */
// 
// 
// // derived by text input or browser
// br.bookId   = '<%=@work.ia_work.book_id%>';
// br.zip      = '<%=@work.ia_work.ia_path%>/<%=@work.ia_work.zip_file%>';
// br.subPrefix = '<%=@work.ia_work.sub_prefix%>';
// br.server   = '<%=@work.ia_work.server %>';
// br.bookTitle= '<%=@work.ia_work.title%>';
// br.bookPath = '<%=@work.ia_work.book_path%>';
// br.bookUrl  = 'http://www.archive.org/details/<%=@work.ia_work.book_id%>';
// br.imageFormat = '<%=@work.ia_work.image_format%>';
// br.archiveFormat = '<%=@work.ia_work.archive_format%>';
// 
// br.pageProgression = 'lr';
// // Check for config object
// // $$$ change this to use the newer params object
// if (typeof(brConfig) != 'undefined') {
    // if (typeof(brConfig["ui"]) != 'undefined') {
        // br.ui = brConfig["ui"];
    // }
// 
    // if (brConfig['mode'] == 1) {
        // br.mode = 1;
        // if (typeof(brConfig['reduce'] != 'undefined')) {
            // br.reduce = brConfig['reduce'];
        // }
    // } else if (brConfig['mode'] == 2) {
        // br.mode = 2;
// 
    // }
// } // brConfig
// 
// br.cleanupMetadata();
// br.init();



// Error reporting - this helps us fix errors quickly
function logError(description,page,line) {
    if (typeof(archive_analytics) != 'undefined') {
        var values = {
            'bookreader': 'error',
            'description': description,
            'page': page,
            'line': line,
            'itemid': 'ThorntonByLolaCarrBates',
            'subPrefix': 'Thornton_by_Lola_Carr_Bates',
            'server': 'ia902608.us.archive.org',
            'bookPath': '\x2F2\x2Fitems\x2FThorntonByLolaCarrBates\x2FThornton_by_Lola_Carr_Bates'
        };

        // if no referrer set '-' as referrer
        if (document.referrer == '') {
            values['referrer'] = '-';
        } else {
            values['referrer'] = document.referrer;
        }

        if (typeof(br) != 'undefined') {
            values['itemid'] = br.bookId;
            values['subPrefix'] = br.subPrefix;
            values['server'] = br.server;
            values['bookPath'] = br.bookPath;
        }

        archive_analytics.send_ping(values);
    }

    return false; // allow browser error handling so user sees there was a problem
}
window.onerror=logError;

br = new BookReader();

br.titleLeaf = 0;

br.getPageWidth = function(index) {
    return this.pageW[index];
}

br.getPageHeight = function(index) {
    return this.pageH[index];
}

// Returns true if page image is available rotated
br.canRotatePage = function(index) {
    return 'jp2' == this.imageFormat; // Assume single format for now
}

// reduce defaults to 1 (no reduction)
// rotate defaults to 0 (no rotation)
br.getPageURI = function(index, reduce, rotate) {
    var _reduce;
    var _rotate;

    if ('undefined' == typeof(reduce)) {
        _reduce = 1;
    } else {
        _reduce = reduce;
    }
    if ('undefined' == typeof(rotate)) {
        _rotate = 0;
    } else {
        _rotate = rotate;
    }

    var file = this._getPageFile(index);

    // $$$ add more image stack formats here
    return '//'+this.server+'/BookReader/BookReaderImages.php?zip='+this.zip+'&file='+file+'&scale='+_reduce+'&rotate='+_rotate;
}

// Get a rectangular region out of a page
br.getRegionURI = function(index, reduce, rotate, sourceX, sourceY, sourceWidth, sourceHeight) {

    // Map function arguments to the url keys
    var urlKeys = ['n', 'r', 'rot', 'x', 'y', 'w', 'h'];
    var page = '';
    for (var i = 0; i < arguments.length; i++) {
        if ('undefined' != typeof(arguments[i])) {
            if (i > 0 ) {
                page += '_';
            }
            page += urlKeys[i] + arguments[i];
        }
    }

    var itemPath = this.bookPath.replace(new RegExp('/'+this.subPrefix+'$'), ''); // remove trailing subPrefix

    return '//'+this.server+'/BookReader/BookReaderImages.php?id=' + this.bookId + '&itemPath=' + itemPath + '&server=' + this.server + '&subPrefix=' + this.subPrefix + '&page=' +page + '.jpg';
}

br._getPageFile = function(index) {
    var leafStr = '0000';
    var imgStr = this.leafMap[index].toString();
    var re = new RegExp("0{"+imgStr.length+"}$");

    var insideZipPrefix = this.subPrefix.match('[^/]+$');
    var file = insideZipPrefix + '_' + this.imageFormat + '/' + insideZipPrefix + '_' + leafStr.replace(re, imgStr) + '.' + this.imageFormat;

    return file;
}

br.getPageSide = function(index) {
    //assume the book starts with a cover (right-hand leaf)
    //we should really get handside from scandata.xml

    
    // $$$ we should get this from scandata instead of assuming the accessible
    //     leafs are contiguous
    if ('rl' != this.pageProgression) {
        // If pageProgression is not set RTL we assume it is LTR
        if (0 == (index & 0x1)) {
            // Even-numbered page
            return 'R';
        } else {
            // Odd-numbered page
            return 'L';
        }
    } else {
        // RTL
        if (0 == (index & 0x1)) {
            return 'L';
        } else {
            return 'R';
        }
    }
}

br.getPageNum = function(index) {
    var pageNum = this.pageNums[index];
    if (pageNum) {
        return pageNum;
    } else {
        return 'n' + index;
    }
}

// Single images in the Internet Archive scandata.xml metadata are (somewhat incorrectly)
// given a "leaf" number.  Some of these images from the scanning process should not
// be displayed in the BookReader (for example colour calibration cards).  Since some
// of the scanned images will not be displayed in the BookReader (those marked with
// addToAccessFormats false in the scandata.xml) leaf numbers and BookReader page
// indexes are generally not the same.  This function returns the BookReader page
// index given a scanned leaf number.
//
// This function is used, for example, to map between search results (that use the
// leaf numbers) and the displayed pages in the BookReader.
br.leafNumToIndex = function(leafNum) {
    for (var index = 0; index < this.leafMap.length; index++) {
        if (this.leafMap[index] == leafNum) {
            return index;
        }
    }

    return null;
}

// This function returns the left and right indices for the user-visible
// spread that contains the given index.  The return values may be
// null if there is no facing page or the index is invalid.
br.getSpreadIndices = function(pindex) {
    // $$$ we could make a separate function for the RTL case and
    //      only bind it if necessary instead of always checking
    // $$$ we currently assume there are no gaps

    var spreadIndices = [null, null];
    if ('rl' == this.pageProgression) {
        // Right to Left
        if (this.getPageSide(pindex) == 'R') {
            spreadIndices[1] = pindex;
            spreadIndices[0] = pindex + 1;
        } else {
            // Given index was LHS
            spreadIndices[0] = pindex;
            spreadIndices[1] = pindex - 1;
        }
    } else {
        // Left to right
        if (this.getPageSide(pindex) == 'L') {
            spreadIndices[0] = pindex;
            spreadIndices[1] = pindex + 1;
        } else {
            // Given index was RHS
            spreadIndices[1] = pindex;
            spreadIndices[0] = pindex - 1;
        }
    }

    //console.log("   index %d mapped to spread %d,%d", pindex, spreadIndices[0], spreadIndices[1]);

    return spreadIndices;
}

// Remove the page number assertions for all but the highest index page with
// a given assertion.  Ensures there is only a single page "{pagenum}"
// e.g. the last page asserted as page 5 retains that assertion.
br.uniquifyPageNums = function() {
    if (br.pageNums.length == 0)return;
    var seen = {};

    for (var i = br.pageNums.length - 1; i--; i >= 0) {
        var pageNum = br.pageNums[i];
        if ( !seen[pageNum] ) {
            seen[pageNum] = true;
        } else {
            br.pageNums[i] = null;
        }
    }

}

br.cleanupMetadata = function() {
    br.uniquifyPageNums();
}

// getEmbedURL
//________
// Returns a URL for an embedded version of the current book
br.getEmbedURL = function(viewParams) {
    // We could generate a URL hash fragment here but for now we just leave at defaults
    var url = 'https://' + window.location.host + '/stream/'+this.bookId;
    if (this.subPrefix != this.bookId) { // Only include if needed
        url += '/' + this.subPrefix;
    }
    url += '?ui=embed';
    if (typeof(viewParams) != 'undefined') {
        url += '#' + this.fragmentFromParams(viewParams);
    }
    return url;
}

// getEmbedCode
//________
// Returns the embed code HTML fragment suitable for copy and paste
br.getEmbedCode = function(frameWidth, frameHeight, viewParams) {
    return "<iframe src='" + this.getEmbedURL(viewParams) + "' width='" + frameWidth + "' height='" + frameHeight + "' frameborder='0' ></iframe>";
}


// getOpenLibraryRecord
br.getOpenLibraryRecord = function(callback) {
    // Try looking up by ocaid first, then by source_record

    var self = this; // closure

    var jsonURL = self.olHost + '/query.json?type=/type/edition&*=&ocaid=' + self.bookId;
    $.ajax({
        url: jsonURL,
        success: function(data) {
            if (data && data.length > 0) {
                callback(self, data[0]);
            } else {
                // try sourceid
                jsonURL = self.olHost + '/query.json?type=/type/edition&*=&source_records=ia:' + self.bookId;
                $.ajax({
                    url: jsonURL,
                    success: function(data) {
                        if (data && data.length > 0) {
                            callback(self, data[0]);
                        }
                    },
                    dataType: 'jsonp'
                });
            }
        },
        dataType: 'jsonp'
    });
}

br.buildInfoDiv = function(jInfoDiv) {
    // $$$ it might make more sense to have a URL on openlibrary.org that returns this info

    var escapedTitle = BookReader.util.escapeHTML(this.bookTitle);
    var domainRe = /(\w+\.(com|org))/;
    var domainMatch = domainRe.exec(this.bookUrl);
    var domain = this.bookUrl;
    if (domainMatch) {
        domain = domainMatch[1];
    }

    // $$$ cover looks weird before it loads
    jInfoDiv.find('.BRfloatCover').append([
                    '<div style="height: 140px; min-width: 80px; padding: 0; margin: 0;"><a href="', this.bookUrl, '"><img src="//archive.org/download/', this.bookId, '/page/cover_t.jpg" alt="' + escapedTitle + '" height="140px" /></a></div>'].join('')
    );

    var download_links = [];
    if (!this.olAuth) {
        download_links = [
            '<h3>Other Formats</h3>',
            '<ul class="links">',
                '<li><a href="//archive.org/download/', this.bookId, '/', this.subPrefix, '.pdf">PDF</a><span>|</span></li>',
                '<li><a href="//archive.org/download/', this.bookId, '/', this.subPrefix, '_djvu.txt">Plain Text</a><span>|</span></li>',
                '<li><a href="//archive.org/download/', this.bookId, '/', this.subPrefix, '_daisy.zip">DAISY</a><span>|</span></li>',
                '<li><a href="//archive.org/download/', this.bookId, '/', this.subPrefix, '.epub">ePub</a><span>|</span></li>',
                '<li><a href="https://www.amazon.com/gp/digital/fiona/web-to-kindle?clientid=IA&itemid=', this.bookId, '&docid=', this.subPrefix, '">Send to Kindle</a></li>',
            '</ul>'
        ];
    }

    download_links.push('<p class="moreInfo"><span></span>More information on <a href="'+ this.bookUrl + '">' + domain + '</a>  </p>');

    jInfoDiv.find('.BRfloatMeta').append(download_links.join('\n'));

    jInfoDiv.find('.BRfloatFoot').append([
                '<span>|</span>',
                '<a href="https://openlibrary.org/contact" class="problem">Report a problem</a>',
    ].join('\n'));

    if (domain == 'archive.org') {
        jInfoDiv.find('.BRfloatMeta p.moreInfo span').css(
            {'background': 'url(https://archive.org/favicon.ico) no-repeat', 'width': 22, 'height': 18 }
        );
    }

    jInfoDiv.find('.BRfloatTitle a').attr({'href': this.bookUrl, 'alt': this.bookTitle}).text(this.bookTitle);
    var bookPath = (window.location + '').replace('#','%23');
    jInfoDiv.find('a.problem').attr('href','https://openlibrary.org/contact?path=' + bookPath);

}

br.pageW =  [
            7310,7161,7265,7451,7271,7300,7406,7200,7383,7226,7408,7269,7436,7298,7255,7192,7432,7334,7428,7210,7412,7453,7338,7212,7391,7135,7424,7265,7202,7210,7343,7230,7418,7218            ];

br.pageH =  [
            9591,9481,9559,9695,9565,9585,9663,9510,9646,9530,9665,9563,9685,9583,9553,9504,9681,9610,9679,9518,9667,9697,9614,9520,9653,9463,9675,9559,9512,9518,9618,9534,9671,9524            ];
br.leafMap = [
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33            ];

br.pageNums = [
            null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null            ];


br.numLeafs = br.pageW.length;


br.bookId   = 'ThorntonByLolaCarrBates';
br.zip      = '\x2F2\x2Fitems\x2FThorntonByLolaCarrBates\x2FThornton_by_Lola_Carr_Bates_jp2.zip';
br.subPrefix = 'Thornton_by_Lola_Carr_Bates';
br.server   = 'ia902608.us.archive.org';
br.bookTitle= 'Thornton\x201300\x2D1917';
br.bookPath = '\x2F2\x2Fitems\x2FThorntonByLolaCarrBates\x2FThornton_by_Lola_Carr_Bates';
br.bookUrl  = 'https://archive.org/details/ThorntonByLolaCarrBates';
br.imageFormat = 'jp2';
br.archiveFormat = 'zip';


br.pageProgression = 'lr';
br.olHost = 'https://openlibrary.org';
br.olAuthUrl = null;
br.olAuth = false;

// Check for config object
// $$$ change this to use the newer params object
if (typeof(brConfig) != 'undefined') {
    if (typeof(brConfig["ui"]) != 'undefined') {
        br.ui = brConfig["ui"];
    }

    if (brConfig['mode'] == 1) {
        br.mode = 1;
        if (typeof(brConfig['reduce'] != 'undefined')) {
            br.reduce = brConfig['reduce'];
        }
    } else if (brConfig['mode'] == 2) {
        br.mode = 2;
    }

    if (typeof(brConfig["isAdmin"]) != 'undefined') {
        br.isAdmin = brConfig["isAdmin"];
    } else {
        br.isAdmin = false;
    }

    if (typeof(brConfig["theme"]) != 'undefined') {
        br.theme = brConfig["theme"];
    }
} // brConfig


function OLAuth() {
    this.olConnect = false;
    this.loanUUID = false;
    this.permsToken = false;

    var cookieRe = /;\s*/;
    var cookies = document.cookie.split(cookieRe);
    var length = cookies.length;
    var i;
    for (i=0; i<length; i++) {
        if (0 == cookies[i].indexOf('br-loan-' + br.bookId)) {
            this.loanUUID = cookies[i].split('=')[1];
        }
        if (0 == cookies[i].indexOf('loan-' + br.bookId)) {
            this.permsToken = cookies[i].split('=')[1];
        }

        // Set olHost to use if passed in
        if (0 == cookies[i].indexOf('ol-host')) {
            br.olHost = 'https://' + unescape(cookies[i].split('=')[1]);
        }

        if (0 == cookies[i].indexOf('ol-auth-url')) {
            br.olAuthUrl = unescape(cookies[i].split('=')[1]);
        }
    }

    if (br.olAuthUrl == null) {
        br.olAuthUrl = 'https://archive.org/bookreader/BookReaderAuthProxy.php?id=XXX';
    }

    this.authUrl = br.olAuthUrl.replace("XXX", br.bookId);
    return this;
}

function add_query_param(url, name, value) {
    // Use & if the url already has some query parameters.
    // Use ? otherwise.
    var prefix = (url.indexOf("?") >= 0) ? "&" : "?";
    return url + prefix + name + "=" + value;
}

OLAuth.prototype.init = function() {
    var htmlStr =  'Checking loan status';

    this.showPopup("#F0EEE2", "#000", htmlStr, 'Please wait as we check the status of this book...');
    this.callAuthUrl();
}

OLAuth.prototype.callAuthUrl = function() {
    var authUrl = this.authUrl;

    // be sure to add random param to authUrl to avoid stale cache
    authUrl = add_query_param(authUrl, 'rand', Math.random());

    if (false !== this.loanUUID) {
        authUrl = add_query_param(authUrl, 'loan', this.loanUUID);
    }
    if (false !== this.permsToken) {
        authUrl = add_query_param(authUrl, 'token', this.permsToken);
    }
    $.ajax({url:authUrl, dataType:'jsonp', jsonpCallback:'olAuth.initCallback'});
}

OLAuth.prototype.showPopup = function(bgColor, textColor, msg, resolution) {
    this.popup = document.createElement("div");
    $(this.popup).css({
        position: 'absolute',
        top:      '50px',
        left:     ($('#BookReader').attr('clientWidth')-400)/2 + 'px',
        width:    '400px',
        padding:  "15px",
        border:   "3px double #999999",
        zIndex:   3,
        textAlign: 'center',
        backgroundColor: bgColor,
        color: textColor
    }).appendTo('#BookReader');

    this.setPopupMsg(msg, resolution);

}

OLAuth.prototype.setPopupMsg = function(msg, resolution) {
    this.popup.innerHTML = ['<p><strong>', msg, '</strong></p><p>', resolution, '</p>'].join('\n');
}

OLAuth.prototype.showError = function(msg, resolution) {
   $(this.popup).css({
        backgroundColor: "#fff",
        color: "#000"
    });

    this.setPopupMsg(msg, resolution);
}

OLAuth.prototype.initCallback = function(obj) {
    if (false == obj.success) {
        if (br.isAdmin) {
            ret = confirm("We couldn't authenticate your loan with Open Library, but since you are an administrator or uploader of this book, you can access this book for QA purposes. Would you like to QA this book?");
            if (!ret) {
                this.showError(obj.msg, obj.resolution)
            } else {
                br.init();
            }
        } else {
            this.showError(obj.msg, obj.resolution)
        }
    } else {
        //user is authenticated
        this.setCookie(obj.token);
        this.olConnect = true;
        this.startPolling();
        br.init();
    }
}

OLAuth.prototype.callback = function(obj) {
    if (false == obj.success) {
        this.showPopup("#F0EEE2", "#000", obj.msg, obj.resolution);
        clearInterval(this.poller);
        this.ttsPoller = null;
    } else {
        this.olConnect = true;
        this.setCookie(obj.token);
    }
}

OLAuth.prototype.setCookie = function(value) {
    var date = new Date();
    date.setTime(date.getTime()+(10*60*1000));  //10 min expiry
    var expiry = date.toGMTString();
    var cookie = 'loan-'+br.bookId+'='+value;
    cookie    += '; expires='+expiry;
    cookie    += '; path=/; domain=.archive.org;';
    document.cookie = cookie;
    this.permsToken = value;

    //refresh the br-loan uuid cookie with current expiry, if needed
    if (false !== this.loanUUID) {
        cookie = 'br-loan-'+br.bookId+'='+this.loanUUID;
        cookie    += '; expires='+expiry;
        cookie    += '; path=/; domain=.archive.org;';
        document.cookie = cookie;
    }
}

OLAuth.prototype.deleteCookies = function() {
    var date = new Date();
    date.setTime(date.getTime()-(24*60*60*1000));  //one day ago
    var expiry = date.toGMTString();
    var cookie = 'loan-'+br.bookId+'=""';
    cookie    += '; expires='+expiry;
    cookie    += '; path=/; domain=.archive.org;';
    document.cookie = cookie;

    cookie = 'br-loan-'+br.bookId+'=""';
    cookie    += '; expires='+expiry;
    cookie    += '; path=/; domain=.archive.org;';
    document.cookie = cookie;
}

OLAuth.prototype.startPolling = function () {
    var self = this;
    this.poller=setInterval(function(){
        if (!self.olConnect) {
          self.showPopup("#F0EEE2", "#000", 'Connection error', 'The BookReader cannot reach Open Library. This might mean that you are offline or that Open Library is down. Please check your Internet connection and refresh this page or try again later.');
          clearInterval(self.poller);
          self.ttsPoller = null;
        } else {
          self.olConnect = false;
          self.callAuthUrl();
        }
    },300000);   //five minute interval
}

br.cleanupMetadata();
if (br.olAuth) {
    var olAuth = new OLAuth();
    olAuth.init();
} else {
    br.init();
}



	</script>
		</div>
    </div>
</div>
